Configuration:

    type MyRoutes = IsakSky.RouteProvider<routes, true>


Generated code with input type:

    [lang=fsharp]
    // Generated by RouteProvider 0.0.0.0
    namespace IsakSky
    
    open System
    module Provided =
      let getProject (projectId:int64) =
          "projects/" + projectId.ToString()
      let getProjectComments (projectId:int64) (commentId:int64) =
          "projects/" + projectId.ToString() + "comments/" + commentId.ToString()
      let updateProject (projectId:int) =
          "projects/" + projectId.ToString()
      let GET__projects_statistics  =
          "projects/statistics/"
      let getPerson (name:string) =
          "people/" + name
    
      module Internal =
        let fakeBaseUri = new Uri("http://a.a")
    
        exception RouteNotMatchedException of string * string
    
      type MyRoutes2<'TContext> =
        { getProject: 'TContext->int64->unit
          getProjectComments: 'TContext->int64->int64->unit
          updateProject: 'TContext->int->unit
          GET__projects_statistics: 'TContext->unit
          getPerson: 'TContext->string->unit
          notFound: ('TContext->string->string->unit) option }
    
        member inline private this.HandleNotFound(context, verb, path) =
          match this.notFound with
          | None -> raise (Internal.RouteNotMatchedException (verb, path))
          | Some(notFound) -> notFound context verb path
    
        member this.DispatchRoute(context:'TContext, verb:string, path:string) : unit =
          let parts = path.Split('/')
          let start = if parts.[0] = "" then 1 else 0
          let endOffset = if parts.Length > 0 && parts.[parts.Length - 1] = "" then 1 else 0
          match parts.Length - start - endOffset with
          // {endPoints = [];
          //  children =
          //   [(ConstantSeg "projects",
          //     {endPoints = [];
          //      children =
          //       [(Int64Seg "projectId",
          //         {endPoints = [];
          //          children =
          //           [(ConstantSeg "comments",
          //             {endPoints = [];
          //              children =
          //               [(Int64Seg "commentId",
          //                 {endPoints = [{verb = "GET";
          //                                handlerName = "getProjectComments";}];
          //                  children = [];
          //                  depth = 4;})];
          //              depth = 3;})];
          //          depth = 2;})];
          //      depth = 1;})];
          //  depth = 0;}
          | 4 ->
            if String.Equals(parts.[0 + start],"projects") then
              let mutable projectId = 0L
              if Int64.TryParse(parts.[1 + start], &projectId) then
                if String.Equals(parts.[2 + start],"comments") then
                  let mutable commentId = 0L
                  if Int64.TryParse(parts.[3 + start], &commentId) then
                    if verb = "GET" then this.getProjectComments projectId commentId
                    else this.HandleNotFound(context, verb, path)
                  else this.HandleNotFound(context, verb, path)
                else this.HandleNotFound(context, verb, path)
              else this.HandleNotFound(context, verb, path)
            else this.HandleNotFound(context, verb, path)
          // {endPoints = [];
          //  children =
          //   [(ConstantSeg "people",
          //     {endPoints = [];
          //      children = [(StringSeg "name", {endPoints = [{verb = "GET";
          //                                                    handlerName = "getPerson";}];
          //                                      children = [];
          //                                      depth = 2;})];
          //      depth = 1;});
          //    (ConstantSeg "projects",
          //     {endPoints = [];
          //      children =
          //       [(ConstantSeg "statistics",
          //         {endPoints = [{verb = "GET";
          //                        handlerName = "GET__projects_statistics";}];
          //          children = [];
          //          depth = 2;});
          //        (IntSeg "projectId", {endPoints = [{verb = "PUT";
          //                                            handlerName = "updateProject";}];
          //                              children = [];
          //                              depth = 2;});
          //        (Int64Seg "projectId", {endPoints = [{verb = "GET";
          //                                              handlerName = "getProject";}];
          //                                children = [];
          //                                depth = 2;})];
          //      depth = 1;})];
          //  depth = 0;}
          | 2 ->
            if String.Equals(parts.[0 + start],"people") then
              let name = parts.[1 + start]
              if verb = "GET" then this.getPerson name
              else this.HandleNotFound(context, verb, path)
            elif String.Equals(parts.[0 + start],"projects") then
              let mutable projectId = 0L
              let mutable projectId = 0
              if String.Equals(parts.[1 + start],"statistics") then
                if verb = "GET" then this.GET__projects_statistics 
                else this.HandleNotFound(context, verb, path)
              elif Int64.TryParse(parts.[1 + start], &projectId) then
                if verb = "GET" then this.getProject projectId
                else this.HandleNotFound(context, verb, path)
              elif Int32.TryParse(parts.[1 + start], &projectId) then
                if verb = "PUT" then this.updateProject projectId
                else this.HandleNotFound(context, verb, path)
              else this.HandleNotFound(context, verb, path)
            else this.HandleNotFound(context, verb, path)
          | _ ->
            this.HandleNotFound(context, verb, path)
    
        member this.DispatchRoute(context:'TContext, verb:string, uri:Uri) : unit =
          // Ensure we have an Absolute Uri, or just about every method on Uri chokes
          let uri = if uri.IsAbsoluteUri then uri else new Uri(Internal.fakeBaseUri, uri)
          let path = uri.GetComponents(UriComponents.Path, UriFormat.Unescaped)
          this.DispatchRoute(verb, path)
    
    