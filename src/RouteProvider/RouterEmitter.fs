namespace IsakSky.RouteProvider

open Route
open RouteCompilation
open System.IO
open System
open Microsoft.FSharp.Compiler.SourceCodeServices
open Utility
open System.Runtime.InteropServices
open RouteCompilation

type RouterEmissionArgs = {
  typeName: string
  parse: Route list
  outputPath: string
  inputType: bool
  returnType: bool
  nameSpace: string option
  moduleName: string option
} 

type RouterEmissionMessage =
| Enqueue of RouterEmissionArgs * AsyncReplyChannel<RouterEmissionResult>
and RouterEmissionResult = 
| IgnoredStale
| IgnoredBadExtension
| Ok
| OkSecondaryThread
| RefuseFilenameTaken

type EmitterState = {
  lastWrote: DateTime
}

module RouterEmitterUtils =
  let fileIsGeneratedOrEmpty (file:FileStream) =
    if file.Length = 0L then true
    else
      let reader = new StreamReader(file)
      let mutable allWhitespace  = true
      let mutable foundGenComment = false
      while not foundGenComment && not (reader.EndOfStream) do
        let line = reader.ReadLine()
        if line.Contains("// Generated by RouteProvider") then
          foundGenComment <- true
        elif not <| String.IsNullOrWhiteSpace(line) then
          allWhitespace <- false
      foundGenComment || allWhitespace

type RouterEmitter(outputPath : string) = 
  let expire = new Event<EventHandler,EventArgs>()
  let maxWait = 200
  let waitIncr = 50
  let maxWaitNoMessage = 2000
  let waitNonExistantFile = 3000

//  do
//    log "[RouterEmitter]: Starting for %s" outputPath

  member private this.HandleMessage(emissionArgs:RouterEmissionArgs) =
    let path = emissionArgs.outputPath
    Directory.CreateDirectory(Path.GetDirectoryName(path)) |> ignore
    try     
      use f = File.Open(emissionArgs.outputPath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None)
      if not <| RouterEmitterUtils.fileIsGeneratedOrEmpty f then
        RefuseFilenameTaken
      else 
        f.SetLength(0L)
        use sw = new StreamWriter(f)
        let compArgs = {
          typeName = emissionArgs.typeName
          parse = emissionArgs.parse
          inputType = emissionArgs.inputType
          returnType = emissionArgs.returnType
          nameSpace = emissionArgs.nameSpace
          moduleName = emissionArgs.moduleName
          outputType = FSharp
        }
        compileRoutes compArgs sw
        Ok
    with
    | :? System.IO.IOException ->
      //log "Ah, someone beat us to it."
      OkSecondaryThread
  member private this.Mail : MailboxProcessor<RouterEmissionMessage> = MailboxProcessor.Start(fun inbox ->
    let rec loop (numSkipped, waited) = 
      async {
        let! msg = inbox.TryReceive(maxWaitNoMessage)
        match msg with
        | None ->
          expire.Trigger(this, new EventArgs())
          do! Async.Sleep waitIncr
          return! loop (numSkipped, waited + waitIncr)
        | Some(Enqueue(args, replyChan)) ->
          if waited < maxWait then do! Async.Sleep waitIncr
          if waited < maxWait && inbox.CurrentQueueLength > 0 then
            replyChan.Reply(IgnoredStale)
            return! loop (numSkipped + 1, waited + waitIncr)
          else
            // We're on the last message, or have waited long enough
            // lets process it. Maybe.
            let outputFile = args.outputPath
            if not <| outputFile.EndsWith(".fs") then
              replyChan.Reply(IgnoredBadExtension)
            else
              if not <| File.Exists(outputFile) then
                // Wait a little bit more before creating it, 
                // in case they are still working out the filename
                do! Async.Sleep(waitNonExistantFile)
                if inbox.CurrentQueueLength > 0 then
                  replyChan.Reply(IgnoredStale)
                  return! loop (numSkipped + 1, waited + waitNonExistantFile)
                else
                  replyChan.Reply <| this.HandleMessage(args)
                  return! loop (numSkipped, 0)
              else
                replyChan.Reply <| this.HandleMessage(args)
                return! loop (numSkipped, 0)
            return! loop (numSkipped, 0)
      }      
    loop (0, 0))

  member this.PostMessage(args:RouterEmissionArgs) =
    //this.Mail.PostAndReply(fun chan -> Enqueue(args, chan))
    this.Mail.PostAndReply(fun chan -> Enqueue(args, chan))
  
  [<CLIEvent>]
  member this.Expired =
    expire.Publish
