namespace IsakSky.RouteProvider

open Route
open RouteCompilation
open System.IO
open System
open Utility
open System.Runtime.InteropServices
open RouteCompilation

type RouterEmissionArgs = {
  typeName: string
  parse: Route list
  outputPath: string
  inputType: bool
  returnType: bool
  nameSpace: string option
  moduleName: string option
}

type RouterEmissionMessage =
| Enqueue of RouterEmissionArgs * AsyncReplyChannel<RouterEmissionResult>
and RouterEmissionResult =
| IgnoredStale
| IgnoredBadExtension
| Ok
| OkSecondaryThread
| RefuseFilenameTaken

type EmitterState = {
  lastWrote: DateTime
}

module RouterEmitterUtils =
  type [<RequireQualifiedAccess>] FileCheckResult =
  | Empty
  | Generated
  | UpToDate
  | Taken

  let checkFile (file:FileStream) (emissionArgs:RouteCompilationArgs) =
    if file.Length = 0L then FileCheckResult.Empty
    else
      let reader = new StreamReader(file)
      let mutable allWhitespace  = true
      let mutable isUpToDate = false
      let mutable foundGenComment = false

      let upToDateStr = genFileStart (AssemblyVersionInformation.Version) (emissionArgs.GetHashCode())

      while not foundGenComment && not (reader.EndOfStream) do
        let line = reader.ReadLine()
        if line.Contains("// Generated by RouteProvider") then
          foundGenComment <- true
          if line = upToDateStr then isUpToDate <- true
        elif not <| String.IsNullOrWhiteSpace(line) then
          allWhitespace <- false

      if isUpToDate then FileCheckResult.UpToDate
      elif allWhitespace then FileCheckResult.Empty
      elif foundGenComment then FileCheckResult.Generated
      else FileCheckResult.Taken

type RouterEmitter(outputPath : string) =
  let expire = new Event<EventHandler,EventArgs>()
  static let [<Literal>] maxWait = 200
  static let [<Literal>] waitIncr = 50
  static let [<Literal>] maxWaitNoMessage = 2000
  static let [<Literal>] waitNonExistantFile = 3000

//  do
//    log "[RouterEmitter]: Starting for %s" outputPath

  member private this.HandleMessage(emissionArgs:RouterEmissionArgs) =
    let path = emissionArgs.outputPath
    Directory.CreateDirectory(Path.GetDirectoryName(path)) |> ignore
    let compArgs = {
          typeName = emissionArgs.typeName
          parse = emissionArgs.parse
          inputType = emissionArgs.inputType
          returnType = emissionArgs.returnType
          nameSpace = emissionArgs.nameSpace
          moduleName = emissionArgs.moduleName
          outputType = FSharp
        }
    try
      use f = File.Open(emissionArgs.outputPath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None)
      match RouterEmitterUtils.checkFile f compArgs with
      | RouterEmitterUtils.FileCheckResult.Empty
      | RouterEmitterUtils.FileCheckResult.Generated ->
        f.SetLength(0L)
        use sw = new StreamWriter(f)
        compileRoutes compArgs sw
        Ok
      | RouterEmitterUtils.FileCheckResult.UpToDate -> Ok
      | RouterEmitterUtils.FileCheckResult.Taken -> RefuseFilenameTaken
    with
    | :? System.IO.IOException ->
      OkSecondaryThread

  member private this.Mail : MailboxProcessor<RouterEmissionMessage> = MailboxProcessor.Start(fun inbox ->
    let rec loop (numSkipped, waited) =
      async {
        let! msg = inbox.TryReceive(maxWaitNoMessage)
        match msg with
        | None ->
          expire.Trigger(this, new EventArgs())
          do! Async.Sleep waitIncr
          return! loop (numSkipped, waited + waitIncr)
        | Some(Enqueue(args, replyChan)) ->
          if waited < maxWait then do! Async.Sleep waitIncr
          if waited < maxWait && inbox.CurrentQueueLength > 0 then
            replyChan.Reply(IgnoredStale)
            return! loop (numSkipped + 1, waited + waitIncr)
          else
            // We're on the last message, or have waited long enough
            // lets process it. Maybe.
            let outputFile = args.outputPath
            if not <| outputFile.EndsWith(".fs") then
              replyChan.Reply(IgnoredBadExtension)
            else
              if not <| File.Exists(outputFile) then
                // Wait a little bit more before creating it,
                // in case they are still working out the filename
                do! Async.Sleep(waitNonExistantFile)
                if inbox.CurrentQueueLength > 0 then
                  replyChan.Reply(IgnoredStale)
                  return! loop (numSkipped + 1, waited + waitNonExistantFile)
                else
                  replyChan.Reply <| this.HandleMessage(args)
                  return! loop (numSkipped, 0)
              else
                replyChan.Reply <| this.HandleMessage(args)
                return! loop (numSkipped, 0)
            return! loop (numSkipped, 0)
      }
    loop (0, 0))

  member this.PostMessage(args:RouterEmissionArgs) =
    //this.Mail.PostAndReply(fun chan -> Enqueue(args, chan))
    this.Mail.PostAndReply(fun chan -> Enqueue(args, chan))

  [<CLIEvent>]
  member this.Expired =
    expire.Publish
